#pragma config(Sensor, S1,     back,           sensorEV3_Touch, modeEV3Bump)
#pragma config(Sensor, S2,     left_ultrasonic, sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     front_ultrasonic, sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          L_motor,       tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          L_klepeto,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          R_klepeto,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          R_motor,       tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//stuone otoceni jsou kalibrovane na medveda bez medveda to nefunguje!!!!!!!!!!!
//jheswevfhsfbvkhehsgrvfbvufvtb
////shdbvjhsdvhsdvjsd
const float wheel_diameter = 70; // prumer kola
const float wheel_base = 148;	 // rozvor kol
const float speed = 60;			 // rychlost jizdy
short average_left;				 // konstanata pro plovouci prumer
int g_encoder;					 // promenne tady jen aby se vypisovaly
int g_front_sensor;				 // promenne tady jen aby se vypisovaly
int g_left_sensor = 100;		 // hodnota z leveho senzoru
int a1 = 0,
	a2 = 0,
	a3 = 0,
	a4 = 0,
	a5 = 0;
float distance_avg = 0;

typedef enum
{
	ESKO,
	FIELD1,
	FIELD2,
	FIELD3,
	FIELD4,
	WALL1,
	WALL2,
	WALL3,
	WALL4,
	ESKO_BACK,
	HOME1,
	HOME2,
	ROHY,
	HRISTE
} sectors;
sectors state = ROHY;

void obloukright(short radius, float angle_oblouku)
{ // polomer oblouku pro vnejsi kolo
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	moveMotorTarget(L_motor, ((radius - wheel_base) * 2 * PI) * angle_oblouku / (PI * wheel_diameter), (speed * (radius - wheel_base)) / radius); // vypocet delky oblouku pro kazde kolo
	moveMotorTarget(R_motor, (radius * 2 * PI) * angle_oblouku / (PI * wheel_diameter), speed);													  // vypocet delky oblouku pro kazde kolo
	waitUntilMotorStop(L_motor);
	waitUntilMotorStop(R_motor);
	delay(10);
}

void obloukleft(short radius, float angle_oblouku)
{ // polomer oblouku pro vnejsi kolo
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	moveMotorTarget(R_motor, ((radius - wheel_base) * 2 * PI) * angle_oblouku / (PI * wheel_diameter), (speed * (radius - wheel_base)) / radius); // vypocet delky oblouku pro kazde kolo
	moveMotorTarget(L_motor, (radius * 2 * PI) * angle_oblouku / (PI * wheel_diameter), speed);													  // vypocet delky oblouku pro kazde kolo
	waitUntilMotorStop(L_motor);
	waitUntilMotorStop(R_motor);
	delay(10);
}

// otevirani klepet
void open_klepeto(short open_deg_R, short open_deg_L)
{ // o kolik stupnu se otevre prave klepeto a o kolik leve
	resetMotorEncoder(R_klepeto);
	resetMotorEncoder(L_klepeto);
	moveMotorTarget(R_klepeto, open_deg_R, 20); // prave klepeto se otevira jako prvni aby se nenabouraly
	delay(50);
	moveMotorTarget(L_klepeto, open_deg_L, 20);
	waitUntilMotorStop(R_klepeto);
	waitUntilMotorStop(L_klepeto);
	delay(100);
}

// zavirani klepet
void close_klepeto()
{ // o kolik stupnu se zavre prave klepeto a o kolik leve
	resetMotorEncoder(R_klepeto);
	resetMotorEncoder(L_klepeto);
	setMotorSpeed(R_klepeto, -20); // leve klepeto se zavira jako prvni aby se nenabouraly
	setMotorSpeed(L_klepeto, -20);
	delay(100);
}
void open_klepeto1()
{ // o kolik stupnu se zavre prave klepeto a o kolik leve
	resetMotorEncoder(R_klepeto);
	resetMotorEncoder(L_klepeto);
	setMotorSpeed(R_klepeto, 50); // leve klepeto se zavira jako prvni aby se nenabouraly
	setMotorSpeed(L_klepeto, 50);
	delay(280);//250 funguje
}
// otoceni robota doprava
void turn_right(short turnindeg, short speed)
{
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	moveMotorTarget(L_motor, turnindeg * wheel_base / wheel_diameter, speed);
	moveMotorTarget(R_motor, turnindeg * wheel_base / wheel_diameter, -speed);
	waitUntilMotorStop(L_motor);
	waitUntilMotorStop(R_motor);
	delay(10);
}

// otoceni robota doleva
void turn_left(short turnindeg, short speed)
{
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	moveMotorTarget(L_motor, turnindeg * wheel_base / wheel_diameter, -speed);
	moveMotorTarget(R_motor, turnindeg * wheel_base / wheel_diameter, speed);
	waitUntilMotorStop(L_motor);
	waitUntilMotorStop(R_motor);
	delay(10);
}

// jizda na enkodery dopredu
void forward1(short lenght)
{ // delka co ma robot ujet v mm
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	moveMotorTarget(L_motor, lenght * 360 / (PI * wheel_diameter), speed+2);
	moveMotorTarget(R_motor, lenght * 360 / (PI * wheel_diameter), speed);
	waitUntilMotorStop(L_motor);
	waitUntilMotorStop(R_motor);
	delay(10);
}

// jizda na encodery dozadu
void backward1(short lenght)
{ // delka co ma robot ujet v mm
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	moveMotorTarget(L_motor, lenght * 360 / (PI * wheel_diameter), -speed);
	moveMotorTarget(R_motor, lenght * 360 / (PI * wheel_diameter), -speed);
	waitUntilMotorStop(L_motor);
	waitUntilMotorStop(R_motor);
	delay(10);
}

// robot couva dokud se nezmackne tlacitko vzadu
void button_back()
{
	setMotorSpeed(R_motor, -speed);
	setMotorSpeed(L_motor, -speed);
	while (getTouchValue(back) == 0)
	{
	}
	setMotorSpeed(R_motor, 0);
	setMotorSpeed(L_motor, 0);
}

void floating_average1(short lenght)
{
resetMotorEncoder(L_motor);
resetMotorEncoder(R_motor);
g_encoder = 0;

	int j = 0;
	int distance[6];
	int distance_sum;

	for (int i = 0; i < 6; i++)
	{ // pocatecni zaplneni pole hodnotami ze senzoru
		distance[i] = getUSDistance(S2);
		delay(20);
	}
	do
	{
 g_encoder = getMotorEncoder(L_motor);
		distance[j] = getUSDistance(S2);
		distance_sum = 0;
		for (int i = 0; i < 6; i++)
		{
			distance_sum += distance[i];
		}
		j++;
		g_left_sensor = distance_sum / 6;
		if (j > 5)
		{
			j = 0;
		}
		delay(100);
	} while ((g_left_sensor>100 && g_left_sensor<255)&& g_encoder <= (lenght * 360 / (PI * wheel_diameter)));
setMotorSpeed(R_motor, 0);
setMotorSpeed(L_motor, 0);
	}


void floating_average()
{

	int j = 0;
	int distance[6];
	int distance_sum;

	for (int i = 0; i < 6; i++)
	{ // pocatecni zaplneni pole hodnotami ze senzoru
		distance[i] = getUSDistance(S2);
		delay(20);
	}
	do
	{

		distance[j] = getUSDistance(S2);
		distance_sum = 0;
		for (int i = 0; i < 6; i++)
		{
			distance_sum += distance[i];
		}
		j++;
		distance_avg = distance_sum / 6;
		if (j > 5)
		{
			j = 0;
		}
		delay(100);
	} while (distance_avg < 60);
}

void bear_search(short measuring_speed, short lenght)
{
	int a1 = 0,
		a2 = 0,
		a3 = 0,
		a4 = 0,
		a5 = 0;
	setMotorSpeed(R_motor, measuring_speed);
	setMotorSpeed(L_motor, measuring_speed);
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	while (g_left_sensor >= 90 )
	{
		g_encoder = getMotorEncoder(R_motor);
		a1 = getUSDistance(S2);
		delay(1);
		a2 = getUSDistance(S2);
		delay(1);
		a3 = getUSDistance(S2);
		delay(1);
		a4 = getUSDistance(S2);
		delay(1);
		a5 = getUSDistance(S2);
		delay(1);
		g_left_sensor = ((a1 + a2 + a3 + a4 + a5) / 5);
	}
	setMotorSpeed(R_motor, 0);
	setMotorSpeed(L_motor, 0);
	while(true){
	if (g_left_sensor <= 90)
	{
		state = HOME1;
		break;
	}
	if ( g_encoder == (lenght * 360 / (PI * wheel_diameter))) // nikdy nesmi byt true
	{
		state = WALL1;
		break;
	}
}
}
// jizda pro medveda
void go_for_bear(short lenght)
{ // delka po ktere robot zastavi
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	setMotorSpeed(R_motor, speed);
	setMotorSpeed(L_motor, speed);
	do
	{
		g_encoder = getMotorEncoder(R_motor);
		g_front_sensor = getUSDistance(S3);
		delay(1);
	} while (g_front_sensor <= 245 && (g_front_sensor > 5 && g_encoder <= (lenght * 360 / (PI * wheel_diameter))));
	delay(1000);
	setMotorSpeed(R_motor, 0);
	setMotorSpeed(L_motor, 0);
}
void front_measuring()
{

	a1 = getUSDistance(S3);
	delay(1);
	a2 = getUSDistance(S3);
	delay(1);
	a3 = getUSDistance(S3);
	delay(1);
	a4 = getUSDistance(S3);
	delay(1);
	a5 = getUSDistance(S3);
	delay(1);
	g_front_sensor = ((a1 + a2 + a3 + a4 + a5) / 5);
	while(true){
	if (g_front_sensor<10)
	{
		state = HOME2;
		break;
	}
	else
	{
		state = FIELD2;
		break;
	}
}
}

// tlacitka pro urceni polohy medveda
void buttons()
{
	while (true)
	{
		if (getButtonPress(buttonUp))//projede vsechny rohy hriste
		{
			button_back();
			forward1(600);
			obloukleft(300, 180);
			forward1(100);
			obloukright(400, 170);
			open_klepeto(90, 90);
			forward1(1600);
			setMotorSpeed(R_motor, 49);
			setMotorSpeed(L_motor, 50);
			delay(1500);
			setMotorSpeed(R_motor, 0);
			setMotorSpeed(L_motor, 0);
			close_klepeto();
			backward1(140);
			obloukright(200, 120);
			button_back();
			open_klepeto1();
			setMotorSpeed(R_klepeto, 0);
			setMotorSpeed(L_klepeto, 0);
			forward1(1050);
			setMotorSpeed(R_motor, 49);
			setMotorSpeed(L_motor, 50);
			delay(500);
			setMotorSpeed(R_motor, 0);
			setMotorSpeed(L_motor, 0);
			close_klepeto();
			backward1(140);
			obloukright(200, 120);
			button_back();
			open_klepeto1();
			setMotorSpeed(R_klepeto, 0);
			setMotorSpeed(L_klepeto, 0);
			forward1(1050);
			setMotorSpeed(R_motor, 49);
			setMotorSpeed(L_motor, 50);
			delay(500);
			setMotorSpeed(R_motor, 0);
			setMotorSpeed(L_motor, 0);
			close_klepeto();
			backward1(140);
			obloukright(200, 120);
			button_back();
			open_klepeto1();
			setMotorSpeed(R_klepeto, 0);
			setMotorSpeed(L_klepeto, 0);
			forward1(1050);
			close_klepeto();
			turn_left(100,40);
			button_back();
					forward1(100);
					turn_left(100, 40);
					button_back();
					forward1(400);
					obloukleft(300, 120);
					forward1(400);
					obloukright(210, 190);
					forward1(50000);
		}
		if (getButtonPress(buttonRight))// projede pravou polovinu hriste
		{
				button_back();
					forward1(600);
					obloukleft(300, 180);
						forward1(100);
			obloukright(400, 170);
					open_klepeto(90, 90);
					setMotorSpeed(R_motor, speed - 2);
					setMotorSpeed(L_motor, speed);
					floating_average(); // hleda konec zdi
					setMotorSpeed(R_motor, 0);
					setMotorSpeed(L_motor, 0);
					forward1(100);
					setMotorSpeed(R_motor, 14);
					setMotorSpeed(L_motor, 15);
					floating_average1(900);
					forward1(100);
					turn_left(90,40);
					button_back();
					go_for_bear(1200);
					close_klepeto();
					button_back();
					turn_right(120,40);
			button_back();
					forward1(100);
					turn_left(110, 40);
					button_back();
					forward1(400);
						obloukleft(300, 120);
					forward1(400);
					obloukright(210, 190);
					forward1(50000);





		}

		if (getButtonPress(buttonLeft))
		{
			button_back();
			forward1(600);
			obloukleft(300, 180);
			forward1(100);
			obloukright(400, 170);
			open_klepeto(90, 90);
			forward1(1600);
			setMotorSpeed(R_motor, 48);
			setMotorSpeed(L_motor, 50);
			delay(1500);
			setMotorSpeed(R_motor, 0);
			setMotorSpeed(L_motor, 0);
			close_klepeto();
			backward1(140);
			obloukright(200, 115);
			button_back();
			open_klepeto1();
			setMotorSpeed(R_klepeto, 0);
			setMotorSpeed(L_klepeto, 0);
			forward1(1050);
			setMotorSpeed(R_motor, 48);
			setMotorSpeed(L_motor, 50);
			delay(500);
			setMotorSpeed(R_motor, 0);
			setMotorSpeed(L_motor, 0);
			close_klepeto();
			backward1(140);
			obloukright(200, 120);
			button_back();
			forward1(150);
			setMotorSpeed(R_motor, 14);
					setMotorSpeed(L_motor, 15);
					floating_average1(850);
					forward1(100);
					turn_left(90,40);
					open_klepeto(90,90);
					button_back();
					go_for_bear(1200);
					close_klepeto();
					button_back();
					forward1(500);
					turn_left(200,200);
					button_back();
					turn_right(110,40);
					button_back();
					forward1(100);
					turn_left(100, 40);
					button_back();
					forward1(400);
							obloukleft(300, 120);
					forward1(400);
					obloukright(210, 190);
					forward1(50000);





		}

		if (getButtonPress(buttonEnter))//projede prvni druhou zed az k druhemu rohu
		{
			button_back();
			forward1(600);
			obloukleft(300, 180);
			forward1(100);
			obloukright(400, 170);
			open_klepeto(90, 90);
			forward1(1600);
			setMotorSpeed(R_motor, 49);
			setMotorSpeed(L_motor, 50);
			delay(1500);
			setMotorSpeed(R_motor, 0);
			setMotorSpeed(L_motor, 0);
			close_klepeto();
			backward1(140);
			obloukright(200, 120);
			button_back();
			open_klepeto1();
			setMotorSpeed(R_klepeto, 0);
			setMotorSpeed(L_klepeto, 0);
			forward1(1050);
			setMotorSpeed(R_motor, 49);
			setMotorSpeed(L_motor, 50);
			delay(500);
			setMotorSpeed(R_motor, 0);
			setMotorSpeed(L_motor, 0);
			close_klepeto();
			delay(100);
			backward1(400);
			turn_left(110, 40);
			forward1(400);
			turn_right(100,40);
			button_back();
			turn_right(100,40);
				button_back();
					forward1(100);
					turn_left(100, 40);
					button_back();
					forward1(400);
							obloukleft(300, 120);
					forward1(400);
					obloukright(210, 190);
					forward1(50000);






		}
			if (getButtonPress(buttonDown))//vezme medveda v prvnim rohu plus na prvni strane
		{
			button_back();
			forward1(600);
			obloukleft(300, 180);
			forward1(100);
			obloukright(400, 170);
			open_klepeto(90, 90);
			forward1(1600);
			setMotorSpeed(R_motor, 49);
			setMotorSpeed(L_motor, 50);
			delay(1500);
			setMotorSpeed(R_motor, 0);
			setMotorSpeed(L_motor, 0);
			close_klepeto();
			delay(100);
			button_back();
					forward1(100);
					turn_left(100, 40);
					button_back();
					forward1(400);
							obloukleft(300, 120);
					forward1(400);
					obloukright(210, 190);
					forward1(50000);

		}




	}
}

task main()
{
	buttons();
}
