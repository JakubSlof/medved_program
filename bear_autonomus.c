#pragma config(Sensor, S1,     back,           sensorEV3_Touch, modeEV3Bump)
#pragma config(Sensor, S2,     left,           sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     frontIR,        sensorEV3_IRSensor)
#pragma config(Motor,  motorA,          L_motor,       tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          L_klepeto,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          R_klepeto,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          R_motor,       tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float wheel_diameter = 140; //prumer kola
const float wheel_base = 200; //rozvor kol
const float speed = 20; //rychlost jizdy
short average_left; //konstanata pro plovouci prumer
int g_encoder;//promenne tady jen aby se vypisovaly 
int g_sensor;//promenne tady jen aby se vypisovaly 

//otevirani klepet
void open_klepeto(short open_deg_R,short open_deg_L ){ //o kolik stupnu se otevre prave klepeto a o kolik leve
	resetMotorEncoder(R_klepeto);
	resetMotorEncoder(L_klepeto);
	moveMotorTarget(R_klepeto, open_deg_R,20);//prave klepeto se otevira jako prvni aby se nenabouraly
	delay(50);
	moveMotorTarget(L_klepeto, open_deg_L,20);
	waitUntilMotorStop(R_klepeto);
	waitUntilMotorStop(L_klepeto);
	delay(100);
}

//zavirani klepet
void close_klepeto(short close_deg_R,short close_deg_L){ //o kolik stupnu se zavre prave klepeto a o kolik leve
	resetMotorEncoder(R_klepeto);
	resetMotorEncoder(L_klepeto);
	moveMotorTarget(R_klepeto, close_deg_L,-20);//leve klepeto se zavira jako prvni aby se nenabouraly
	delay(50);
	moveMotorTarget(L_klepeto, close_deg_R,-20);
	waitUntilMotorStop(R_klepeto);
	waitUntilMotorStop(L_klepeto);
	delay(100);
}

//oblouk doprava
void oblouk_right(short radius){//polomer oblouku pro vnejsi kolo
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	moveMotorTarget(L_motor, (radius*PI)*360/(PI*wheel_diameter), speed);//vypocet delky oblouku pro kazde kolo
	moveMotorTarget(R_motor, ((radius-wheel_base)*PI)*360/(PI*wheel_diameter), (speed*(radius-wheel_base))/radius);//vypocet delky oblouku pro kazde kolo
	waitUntilMotorStop(L_motor);
	waitUntilMotorStop(R_motor);
	delay(10);
}

//oblouk doleva
void oblouk_left(short radius){//polomer oblouku pro vnejsi kolo
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	moveMotorTarget(L_motor,( (radius-wheel_base)*PI)*360/(PI*wheel_diameter), (speed*(radius-wheel_base))/radius);//vypocet delky oblouku pro kazde kolo
	moveMotorTarget(R_motor,(radius*PI)*360/(PI*wheel_diameter), speed );//vypocet delky oblouku pro kazde kolo
	waitUntilMotorStop(L_motor);
	waitUntilMotorStop(R_motor);
	delay(10);

}

//otoceni robota doprava
void turn_right(short turnindeg, short speed){
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	moveMotorTarget(L_motor, turnindeg*wheel_base/wheel_diameter, speed);
	moveMotorTarget(R_motor, turnindeg*wheel_base/wheel_diameter, -speed);
	waitUntilMotorStop(L_motor);
	waitUntilMotorStop(R_motor);
	delay(10);
}

//otoceni robota doleva
void turn_left(short turnindeg, short speed){
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	moveMotorTarget(L_motor, turnindeg*wheel_base/wheel_diameter, -speed);
	moveMotorTarget(R_motor, turnindeg*wheel_base/wheel_diameter, speed);
	waitUntilMotorStop(L_motor);
	waitUntilMotorStop(R_motor);
	delay(10);
}

//jizda na enkodery dopredu
void forward1(short lenght){ //delka co ma robot ujet v mm
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	moveMotorTarget(L_motor, lenght*360/(PI*wheel_diameter), speed);
	moveMotorTarget(R_motor, lenght*360/(PI*wheel_diameter), speed);
	waitUntilMotorStop(L_motor);
	waitUntilMotorStop(R_motor);
	delay(10);
}

//jizda na encodery dozadu
void backward1(short lenght){ //delka co ma robot ujet v mm
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	moveMotorTarget(L_motor, lenght*360/(PI*wheel_diameter), -speed);
	moveMotorTarget(R_motor, lenght*360/(PI*wheel_diameter), -speed);
	waitUntilMotorStop(L_motor);
	waitUntilMotorStop(R_motor);
	delay(10);
}

//robot couva dokud se nezmackne tlacitko vzadu
void button_back(){
setMotorSpeed(R_motor, -speed);
setMotorSpeed(L_motor, -speed);
	while(getTouchValue(back) == 0){
    }
    stopAllMotors();
}

//hledani medveda bocnim senzorem
void field_search(){
	setMotorSpeed(R_motor, speed);
	setMotorSpeed(L_motor, speed);
	short	a1 = 0,
				a2 = 0,
				a3 = 0,
				a4 = 0,
				a5 = 0,
				a6 = 0,
				a7 = 0,
				a8 = 0,
				a9 = 0,
				a10 = 0;
		for(int a = 0; a == 9; a++ ){
			a1 = getUSDistance(S2);
			a2 = a1;
			a3 = a2;
			a4 = a3;
			a5 = a4;
			a6 = a5;
			a7 = a6;
			a8 = a7;
			a9 = a8;
			a10 = a9;
			delay(60);
		}
		do{
			a1 = getUSDistance(S2);
			a2 = a1;
			a3 = a2;
			a4 = a3;
			a5 = a4;
			a6 = a5;
			a7 = a6;
			a8 = a7;
			a9 = a8;
			a10 = a9;
			average_left = (a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10)/10;

			delay(60);
		}while(average_left > 100 && average_left < 120);

		stopAllMotors();
}

// projeti eska s oblouky 
void esko_oblouk(){
	button_back();
	forward1(900);
	oblouk_right(400);
	oblouk_left(400);
	button_back();
}

// projeti eska
void esko(){
	button_back();
	forward1(900);
	turn_right(90,25);
	forward1(400);
	turn_right(90,25);
	forward1(600);
	turn_left(90,25);
	forward1(480);
	turn_left(90,25);
	button_back();
}

//projeti eska zpatky
void esko_back(){
	button_back();
	forward1(80);
	turn_left(90,25);
	forward1(500);
	turn_right(90,25);
	forward1(450);
	turn_left(90,25);
	forward1(450);
	turn_left(90,25);
	forward1(800);
}

//jizda pro medveda  
void go_for_bear(short lenght){ //delka po ktere robot zastavi
	resetMotorEncoder(L_motor);
	resetMotorEncoder(R_motor);
	setMotorSpeed(R_motor, speed);
	setMotorSpeed(L_motor, speed);
	do{
	g_encoder = getMotorEncoder(R_motor);
	g_sensor =  getIRDistance(S3);
	delay(1);
	}while(g_sensor > 5 && g_encoder >= - (lenght*360/(PI*wheel_diameter)));
	stopAllMotors();
}

//tlacitka pro urceni polohy medveda
void buttons(){
	while(true){
		if(getButtonPress(buttonUp)){ //pokud se zmackne tlacitko nahoru zacne robot hledat v pasu jedna
			esko();
			forward1(1500);
			turn_left(90,25);
			button_back();
			open_klepeto(100,100);
			go_for_bear(1200);
			close_klepeto(55,55);
			button_back();
			turn_right(90,25);
			esko_back();
		}

		if(getButtonPress(buttonRight)){  //pokud se zmackne tlacitko dolu zacne robot hledat medveda v pasu dva
			esko();
			forward1(1800);
			turn_left(90,50);
			button_back();
			open_klepeto(100,100);
			go_for_bear(1200);
			close_klepeto(55,55);
			button_back();
			turn_right(90,50);
			esko_back();
		}

		if(getButtonPress(buttonDown)){   //pokud se zmackne tlacitko nahoru zacne robot hledat medveda v pasu tri
			//esko();
			//forward1(2000);
			//turn_left(90,25);
			//button_back();
			//open_klepeto(100,100);
			go_for_bear(120);
			close_klepeto(55,55);
			button_back();
			turn_right(90,25);
			esko_back();
		}

		if(getButtonPress(buttonLeft)){   //pokud se zmackne tlacitko nahoru zacne robot hledat medveda v pasu tri
			esko();
			forward1(2150);
			turn_left(90,50);
			button_back();
			open_klepeto(100,100);
			go_for_bear(1200);
			close_klepeto(55,55);
			button_back();
			turn_right(90,50);
			esko_back();
		}

		if(getButtonPress(buttonEnter)){   //pokud se zmackne tlacitko nahoru zacne robot hledat medveda v pasu tri
			esko();
			forward1(2300);
			turn_left(90,50);
			button_back();
			open_klepeto(100,100);
			go_for_bear(1200);
			close_klepeto(55,55);
			button_back();
			turn_right(90,50);
			esko_back();
		}
	}
}

task main(){
	buttons();
}
